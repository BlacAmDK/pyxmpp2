diff -durN libxml2-2.5.7.orig/include/libxml/tree.h libxml2-2.5.7/include/libxml/tree.h
--- libxml2-2.5.7.orig/include/libxml/tree.h	Thu Apr 24 00:03:54 2003
+++ libxml2-2.5.7/include/libxml/tree.h	Mon May 26 13:59:03 2003
@@ -830,7 +830,11 @@
  */
 int		xmlReconciliateNs	(xmlDocPtr doc,
 					 xmlNodePtr tree);
-
+xmlNodePtr	xmlRemoveNs		(xmlNodePtr tree,
+					 xmlNsPtr ns);
+xmlNsPtr	xmlReplaceNs		(xmlNodePtr tree,
+					 xmlNsPtr oldNs,
+					 xmlNsPtr newNs);
 /*
  * Saving.
  */
diff -durN libxml2-2.5.7.orig/python/tests/Makefile.am libxml2-2.5.7/python/tests/Makefile.am
--- libxml2-2.5.7.orig/python/tests/Makefile.am	Thu Apr 17 14:45:05 2003
+++ libxml2-2.5.7/python/tests/Makefile.am	Mon May 26 14:39:39 2003
@@ -28,7 +28,9 @@
     reader6.py	\
     ctxterror.py\
     readererr.py\
-    relaxng.py
+    relaxng.py  \
+    nsops.py
+    
 
 XMLS=		\
     tst.xml	\
diff -durN libxml2-2.5.7.orig/python/tests/nsops.py libxml2-2.5.7/python/tests/nsops.py
--- libxml2-2.5.7.orig/python/tests/nsops.py	Thu Jan  1 01:00:00 1970
+++ libxml2-2.5.7/python/tests/nsops.py	Mon May 26 14:34:23 2003
@@ -0,0 +1,61 @@
+#!/usr/bin/python -u
+import sys
+import libxml2
+
+# Memory debug specific
+libxml2.debugMemory(1)
+
+#
+# Test document
+#
+xml = """<?xml version="1.0"?>
+<root xmlns="http://example.org/default"
+      xmlns:foo="http://example.org/foo"
+      xmlns:unused="http://example.org/unused"
+><son><grandson xmlns="http://example.org/bar"/></son></root>"""
+
+# test removeNs
+doc=libxml2.parseDoc(xml)
+ns=doc.getRootElement().ns()
+try:
+	doc.removeNs(ns)
+except libxml2.treeError:
+	pass
+else:
+	print "Removal of used namespace succeded - wrong!"
+	sys.exit(1)
+
+str = doc.serialize()
+if str != '<?xml version="1.0"?>\n<root xmlns="http://example.org/default" xmlns:foo="http://example.org/foo" xmlns:unused="http://example.org/unused"><son><grandson xmlns="http://example.org/bar"/></son></root>\n':
+    print "removeNs failed"
+    sys.exit(1)
+
+ns=doc.getRootElement().searchNs(doc,"unused")
+doc.removeNs(ns)
+str = doc.serialize()
+if str != '<?xml version="1.0"?>\n<root xmlns="http://example.org/default" xmlns:foo="http://example.org/foo"><son><grandson xmlns="http://example.org/bar"/></son></root>\n':
+    print "removeNs failed"
+    sys.exit(1)
+doc.freeDoc()
+
+# test replaceNs
+doc=libxml2.parseDoc(xml)
+foo_ns=doc.getRootElement().searchNs(doc,"foo")
+bar_ns=doc.xpathEval("//*[name()='grandson']")[0].ns()
+doc.getRootElement().replaceNs(bar_ns,foo_ns)
+doc.getRootElement().removeNs(bar_ns)
+
+str = doc.serialize()
+if str != '<?xml version="1.0"?>\n<root xmlns="http://example.org/default" xmlns:foo="http://example.org/foo" xmlns:unused="http://example.org/unused"><son><foo:grandson/></son></root>\n':
+    print "removeNs failed"
+    sys.exit(1)
+
+doc.freeDoc()
+
+# Memory debug specific
+libxml2.cleanupParser()
+if libxml2.debugMemory(1) == 0:
+    print "OK"
+else:
+    print "Memory leak %d bytes" % (libxml2.debugMemory(1))
+    libxml2.dumpMemory()
diff -durN libxml2-2.5.7.orig/tree.c libxml2-2.5.7/tree.c
--- libxml2-2.5.7.orig/tree.c	Thu Apr 24 16:23:36 2003
+++ libxml2-2.5.7/tree.c	Mon May 26 14:12:24 2003
@@ -5518,6 +5518,190 @@
 }
 
 /**
+ * xmlRemoveNs:
+ * @tree:  a node from which to remove namespace declaration
+ * @ns:  a namespace to remove
+ *
+ * This function removes namespace declaration from a node. It will
+ * refuse to do so if the namespace is used somwhere in the subtree.
+ *
+ * Returns the modified node or NULL in case of error
+ */
+xmlNodePtr
+xmlRemoveNs(xmlNodePtr tree,xmlNsPtr ns) {
+    xmlNsPtr nsDef,prev;
+    xmlNodePtr node = tree;
+    xmlNodePtr declNode = NULL;
+    xmlAttrPtr attr;
+
+    if (ns == NULL) {
+         xmlGenericError(xmlGenericErrorContext,
+                    "xmlRemoveNs : NULL namespace\n");
+         return(NULL);
+    }
+    while (node != NULL) {
+        /*
+         * Check if the namespace is in use by the node
+         */
+        if (node->ns == ns) {
+             xmlGenericError(xmlGenericErrorContext,
+                    "xmlRemoveNs : namespace in use\n");
+             return(NULL);
+        }
+
+        /*
+         * now check for namespace hold by attributes on the node.
+         */
+        attr = node->properties;
+        while (attr != NULL) {
+            if (attr->ns == ns) {
+                xmlGenericError(xmlGenericErrorContext,
+                    "xmlRemoveNs : namespace in use\n");
+                return(NULL);
+            }
+            attr = attr->next;
+        }
+
+        /*
+         * Check if the namespace is declared in the node
+         */
+        nsDef=node->nsDef;
+        while(nsDef != NULL) {
+                if (nsDef == ns) {
+                    declNode = node;
+                    break;
+                }
+                nsDef=nsDef->next;
+        }
+
+        /*
+         * Browse the full subtree, deep first
+         */
+        if (node->children != NULL) {
+            /* deep first */
+            node = node->children;
+        } else if ((node != tree) && (node->next != NULL)) {
+            /* then siblings */
+            node = node->next;
+        } else if (node != tree) {
+            /* go up to parents->next if needed */
+            while (node != tree) {
+                if (node->parent != NULL)
+                    node = node->parent;
+                if ((node != tree) && (node->next != NULL)) {
+                    node = node->next;
+                    break;
+                }
+                if (node->parent == NULL) {
+                    node = NULL;
+                    break;
+                }
+            }
+            /* exit condition */
+            if (node == tree)
+                node = NULL;
+        } else
+            break;
+    }
+
+    /* there is no such namespace declared here */
+    if (declNode == NULL) {
+        xmlGenericError(xmlGenericErrorContext,
+            "xmlRemoveNs : no such namespace declared\n");
+        return(NULL);
+    }
+
+    prev=NULL;
+    nsDef=declNode->nsDef;
+    while(nsDef != NULL) {
+          if (nsDef == ns) {
+              if (prev == NULL) declNode->nsDef=nsDef->next;
+              else prev->next=nsDef->next;
+              xmlFreeNs(ns);
+              break;
+          }
+          prev=nsDef;
+          nsDef=nsDef->next;
+    }
+
+    return(declNode);
+}
+
+/**
+ * xmlReplaceNs:
+ * @tree:  a subtree where the replacement will be done
+ * @oldNs: the old namespace
+ * @newNs: the new namespace
+ *
+ * This function replaces oldNs with newNs evereywhere within the tree.
+ * oldNs declaration is left untouched. xmlReconciliateNs or xmlRemoveNs
+ * should be used afterwards.
+ *
+ * Returns newNs or NULL in case of error
+ */
+xmlNsPtr
+xmlReplaceNs(xmlNodePtr tree,xmlNsPtr oldNs,xmlNsPtr newNs) {
+    xmlNodePtr node = tree;
+    xmlAttrPtr attr;
+
+    if (oldNs == NULL || newNs == NULL) {
+         xmlGenericError(xmlGenericErrorContext,
+                    "xmlReplaceNs : NULL namespace\n");
+         return(NULL);
+    }
+    while (node != NULL) {
+        /*
+         * Check if the namespace is in use by the node
+         */
+        if (node->ns == oldNs) {
+            node->ns = newNs;
+        }
+
+        /*
+         * now check for namespace hold by attributes on the node.
+         */
+        attr = node->properties;
+        while (attr != NULL) {
+            if (attr->ns == oldNs) {
+                node->ns = newNs;
+            }
+            attr = attr->next;
+        }
+
+        /*
+         * Browse the full subtree, deep first
+         */
+        if (node->children != NULL) {
+            /* deep first */
+            node = node->children;
+        } else if ((node != tree) && (node->next != NULL)) {
+            /* then siblings */
+            node = node->next;
+        } else if (node != tree) {
+            /* go up to parents->next if needed */
+            while (node != tree) {
+                if (node->parent != NULL)
+                    node = node->parent;
+                if ((node != tree) && (node->next != NULL)) {
+                    node = node->next;
+                    break;
+                }
+                if (node->parent == NULL) {
+                    node = NULL;
+                    break;
+                }
+            }
+            /* exit condition */
+            if (node == tree)
+                node = NULL;
+        } else
+            break;
+    }
+
+    return(newNs);
+}
+
+/**
  * xmlHasProp:
  * @node:  the node
  * @name:  the attribute name
